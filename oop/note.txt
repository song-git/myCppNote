
1、面向对象编程的关键思想是多态性

2、面向对象编程的三个基本要素是：封装、继承、多态

3、在C++中，基类必须指出希望派生类重定义哪些函数，
   定义为virtual的函数是基类期待派生类重新定义的

4、保留字virtual的作用是启用动态绑定

5、virtual关键字只在类内部的成员函数声明中出现
   不能用在类定义体外部出现的函数定义上

6*、派生类对其基类类型对象的protected成员没有特殊访问权限

7*、派生类中虚函数的声明必须与基类中定义的方式完全相同
	但有一个例外：返回对基类的引用（指针）的虚函数，派生类中的虚函数可以返回派生类的引用（指针）

8、派生类重定义虚函数时，可以使用virtual关键字，但不是必须这样做

9、已定义的类才能用作基类，这一规则暗示着不可能从类自身派生出一个类

10、触发动态绑定的两个条件：
	第一：只有定义为虚函数的成员函数才能进行动态绑定
	第二：必须通过基类类型的引用或指针进行函数调用

11、派生类虚函数调用基类版本时，必须显示使用作用域操作符

12、派生访问标号将控制派生类的用户对基类继承而来的成员的访问

13、使用class定义的派生类默认具有private继承，使用struct定义的类默认具有public继承

14、友元关系不能继承

15、可以将派生类的引用或指针转换为基类的引用或指针
	但，没有从派生类对象到基类对象的直接转换

16、构造函数和复制控制成员不能继承，每个类定义自己的构造函数和复制控制成员

17、派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继承成员
	派生类构造函数通过将基类包含在构造函数初始化列表中来间接初始化继承成员

18、只能初始化直接基类，通过直接基类初始化间接基类

19、类是否需要定义复制控制成员完全取决于类自身的直接成员

20、如果派生类定义了自己的复制构造函数，该复制构造函数一般应显示使用基类复制构造函数

21、派生类析构函数不负责撤销基类对象的成员
	编译器总是显示调用派生类对象基类部分的析构函数

22、因为，可能会删除实际指向派生类对象的基类类型指针
	因此，要保证运行适当的析构函数，基类中的析构函数必须为虚函数

23、在复制控制成员中，只有析构函数应定义为虚函数
	(虚函数必须在基类和派生类中具有同样的形参)

24、运行构造函数和析构函数时，对象都是不完整的
	如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本
	BUG: 从基类构造函数（析构函数）调用虚函数的派生类版本！！！

25、与基类成员同名的派生类成员将屏蔽对基类成员的直接访问
	但，可以使用作用域操作符访问被屏蔽的基类成员
	在基类和派生类中使用同一名字的成员函数，其行为也一样，即使函数原型不同
	可以在类定义时利用using funcName;来使得基类的函数在派生类中可见，包括所有的重载版本

26、含有（或继承）一个或多个纯虚函数的类是抽象基类，不能创建抽象基类的对象
